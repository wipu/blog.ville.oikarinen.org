<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
  <title>Mapping thoughts to language</title>
  <link>http://blog.ville.oikarinen.org</link>
  <atom:link href="http://blog.ville.oikarinen.org/rss.xml" rel="self" type="application/rss+xml"/>
  <description>Ville Oikarinen blogging (mostly) about programming since 2005</description>
  <language>en-us</language>
  <copyright>(c) Ville Oikarinen 2005 -</copyright>
  <lastBuildDate>Tue, 27 Mar 2018 08:08:40 +0300</lastBuildDate>
  <generator>Some simple custom java code</generator>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/I_m_back.html</guid>
      <title>I'm back</title>
      <link>http://blog.ville.oikarinen.org/I_m_back.html</link>
      <pubDate>Tue Mar 27 07:30:48 2018 +0300</pubDate>
      <category>General</category>
      <description>&lt;p&gt;
  Almost seven years since my &lt;a href=&quot;Dependency_visibility.html&quot;&gt;last post&lt;/a&gt;! And since then the site hosting my blog (jroller.com, RIP) has gone down.
&lt;/p&gt;

&lt;p&gt;
  But now I&apos;m back(ed up by &lt;a href=&quot;https://github.com/wipu/blog.ville.oikarinen.org&quot;&gt;github&lt;/a&gt;). It feels great to use version control for hosting this site.
&lt;/p&gt;

&lt;p&gt;
  Unfortunately I wasn&apos;t able to restore readers&apos; comments from my backups. But future comments will be safe as &lt;a href=&quot;https://github.com/wipu/blog.ville.oikarinen.org/issues&quot;&gt;github issue comments&lt;/a&gt; (thanks to &lt;a href=&quot;https://utteranc.es/&quot;&gt;utteranc.es&lt;/a&gt; by Jeremy Danyow). A github account is needed for commenting (at least for now), but since I&apos;m mostly blogging about programming, that shouldn&apos;t be a problem to my potential target audience.
&lt;/p&gt;

&lt;p&gt;
  Comments are welcome, either publicly on this site or privately to my firstname at lastname dot org email address. Oh, and you can also subsribe to the &lt;a href=&quot;rss.xml&quot;&gt;RSS feed&lt;/a&gt;.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Dependency_visibility.html</guid>
      <title>Dependency visibility</title>
      <link>http://blog.ville.oikarinen.org/Dependency_visibility.html</link>
      <pubDate>Fri, 29 Apr 2011 09:01:13 -0400</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
&lt;i&gt;Dependency analysis war story #3&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
After &lt;a href=&quot;http://blog.ville.oikarinen.org/Automated_analysis,_hand-picked_data.html&quot;&gt;analysing&lt;/a&gt; the essential class-level dependencies we were puzzled: the dependencies seemed ok! What was wrong with our code if not dependencies?!
&lt;/p&gt;

&lt;p&gt;
Further study revealed that the problems were caused by &lt;i&gt;indirect&lt;/i&gt; dependencies, especially &lt;i&gt;inheritance&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
We had identified a new concept: &lt;i&gt;dependency visibility&lt;/i&gt;. (At least I am not aware of any tool that analyzes this.) If class A &lt;i&gt;publicly&lt;/i&gt; depends on class B by referring to it in its public signature (&lt;code&gt;javap -public&lt;/code&gt;), then all users of A are forced to depend on B.
&lt;/p&gt;

&lt;p&gt;
We upgraded our script to draw a bold arrow for public dependencies, and this immediately revealed the dependencies that caused our problems. An abstraction is useless (and just adds complexity) if it fails to hide its own dependencies.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Automated_analysis,_hand-picked_data.html</guid>
      <title>Automated analysis, hand-picked data</title>
      <link>http://blog.ville.oikarinen.org/Automated_analysis,_hand-picked_data.html</link>
      <pubDate>Fri, 29 Apr 2011 08:53:16 -0400</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
&lt;i&gt;Dependency analysis war story #2&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
After we had &lt;a href=&quot;http://blog.ville.oikarinen.org/Architecture_design_as_a_graph_layout_problem.html&quot;&gt;designed&lt;/a&gt; what our project&apos;s dependency graph should look like we started evaluating the current status. Certain parts of the code felt too entangled so a dependency analysis would be needed.
&lt;/p&gt;

&lt;p&gt;
Fully automatic dependency analysis is useful for the big picture, but at least in this project it didn&apos;t help (even a DSM generated by &lt;a href=&quot;http://web.sysart.fi/dtangler/&quot;&gt;dtangler&lt;/a&gt;).
&lt;/p&gt;

&lt;p&gt;
Package-level analysis hides essential information, especially if the package structure is messy (i.e. when the code needs analysis most). Class-level analysis either contains too much information or is restricted to one package/module at a time.
&lt;/p&gt;

&lt;p&gt;
The analysis needs to be class-level, because that&apos;s where the devil is. The classes need to be picked from several packages to see the whole picture. But only the &lt;i&gt;essential&lt;/i&gt; classes need to be included so some manual work would be needed.
&lt;/p&gt;

&lt;p&gt;
On the other hand, the actual dependency analysis cannot be manual, because it is too laborous and error-prone and needs to be repeated after each refactoring.
&lt;/p&gt;

&lt;p&gt;
So we combined the best parts of manual and automatic: We hand-picked the classes that best represent the essentials of the program. Then we used some simple scripting to analyse the dependencies between them and draw them as a graph.
&lt;/p&gt;

&lt;p&gt;
The result was as to-the-point as a hand-drawn picture but reliable and repeatable.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Iteration_and_clicks_correlation.html</guid>
      <title>Iteration and clicks correlation</title>
      <link>http://blog.ville.oikarinen.org/Iteration_and_clicks_correlation.html</link>
      <pubDate>Tue, 19 Apr 2011 08:41:42 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
The more frequently a feature is needed, the more valuable it is. And the more valuable a feature, the earlier it should be implemented.
&lt;/p&gt;

&lt;p&gt;
On the other hand, the more frequently a feature is needed, the less UI gestures (clicks) it should require.
&lt;/p&gt;

&lt;p&gt;
Therefore there should be a positive correlation between click count and iteration number for each feature. This could probably be a useful user experience metric.
&lt;/p&gt;

&lt;p&gt;
If only it was possible to calculate this from automated tests and the backlog...
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Architecture_design_as_a_graph_layout_problem.html</guid>
      <title>Architecture design as a graph layout problem</title>
      <link>http://blog.ville.oikarinen.org/Architecture_design_as_a_graph_layout_problem.html</link>
      <pubDate>Fri, 28 Jan 2011 03:34:56 -0500</pubDate>
      <category>Software Architecture</category>
      <description>&lt;h4&gt;(A real story of getting past the layer question)&lt;/h4&gt;
&lt;p&gt;
In a recent project we had very hard time finding a common language to describe our target architecture design. One common argument was about finding the &quot;correct layer&quot; for each piece of the system.
&lt;/p&gt;
&lt;h4&gt;So many ways to create layers, so little value&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&quot;http://blog.ville.oikarinen.org/Software_architecture_is_human-only_communication.html&quot;&gt;Architecture&lt;/a&gt; is often visualized as layers. Although layer is a useful concept, it&apos;s not enough and can be a very restricting way of thinking about the architecture.
&lt;/p&gt;
&lt;p&gt;
A purely layered design is &lt;i&gt;one-dimensional&lt;/i&gt; so the full capacity of the paper or screen is not utilized. When forcing things to layers, different people make different choices, and this makes communication more difficult.
&lt;/p&gt;
&lt;p&gt;
For example, utilities and services are difficult to place in any layer. They are (literally) orthogonal to the layered design, potentially used from anywhere, while the dependencies between the actual layers are more controlled. In addition, I feel that often the &lt;i&gt;interfaces&lt;/i&gt; between layers are forgotten, and &lt;a href=&quot;http://blog.ville.oikarinen.org/Server-client_is_a_deployment_model,_not_architectural.html&quot;&gt;only the implementations are counted as layers&lt;/a&gt;.
&lt;/p&gt;
&lt;h4&gt;It&apos;s about modules and dependencies&lt;/h4&gt;
&lt;p&gt;
Architecture is essentially about dividing a problem into subproblems, or modularization, and managing dependencies between the modules. So, on the abstract level, the big picture of the software is a &lt;a href=&quot;http://blog.ville.oikarinen.org/Why_modules.html&quot;&gt;dependency graph of the modules&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
One day I realized that the only hard part in design is to identify the subproblems and their dependencies. Divide and conquer. That part wasn&apos;t the subject of any arguments. The problem was only about visualizing it. And that, difficult as it seemed for us, is just about applying a &lt;i&gt;graph layout algorithm&lt;/i&gt;, and computers are good at that!
&lt;/p&gt;
&lt;h4&gt;Defining the module graph&lt;/h4&gt;
&lt;p&gt;
So, we started documenting our modules and dependencies as a &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;dot&lt;/a&gt; script (let&apos;s call this simplified and slightly obfuscated example &lt;code&gt;design.dot&lt;/code&gt;):
&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;
digraph G {
node [shape=&quot;record&quot;]
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;
The project was a server with a REST interface. So, there would be a REST API implementation, a model for it and a parser that transforms REST requests to model objects:
&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;
&quot;rest-api-impl&quot; -&gt; &quot;rest-model&quot;
&quot;rest-api-impl&quot; -&gt; &quot;rest-model-parser&quot;
&quot;rest-model-parser&quot; -&gt; &quot;rest-model&quot;
&lt;/pre&gt;&lt;/p&gt;
Since the REST API and model are higly coupled to external requirements, the REST API implementation should delegate domain logic to a dedicated domain API which has its own model. It uses a transformer module to transform between the two models:
&lt;p&gt;&lt;pre&gt;
&quot;rest-api-impl&quot; -&gt; &quot;domain-api&quot;

&quot;domain-api&quot; -&gt; &quot;domain-model&quot;
&quot;rest-api-impl&quot; -&gt; &quot;domain-model&quot;

&quot;rest-api-impl&quot; -&gt; &quot;rest-model-tofrom-domain-model&quot;

&quot;rest-model-tofrom-domain-model&quot; -&gt; &quot;rest-model&quot;
&quot;rest-model-tofrom-domain-model&quot; -&gt; &quot;domain-model&quot;
&lt;/pre&gt;&lt;/p&gt;
The domain API is abstract and it needs an implementation. The implementation also uses the domain model:
&lt;p&gt;&lt;pre&gt;
&quot;domain-api-impl&quot; -&gt; &quot;domain-api&quot;
&quot;domain-api-impl&quot; -&gt; &quot;domain-model&quot;
&lt;/pre&gt;&lt;/p&gt;
The REST API implementation is responsible for authenticating requests using a service. The domain logic uses the same service for authorization.
&lt;p&gt;&lt;pre&gt;
&quot;rest-api-impl&quot; -&gt; &quot;auth-service&quot;
&quot;domain-api-impl&quot; -&gt; &quot;auth-service&quot;
&lt;/pre&gt;&lt;/p&gt;
The domain logic also needs some external services. One of them is persistence for the domain model, and the domain logic shields itself from its details with a DAO interface:
&lt;p&gt;&lt;pre&gt;
&quot;domain-api-impl&quot; -&gt; &quot;ext-services ...&quot;

&quot;domain-api-impl&quot; -&gt; &quot;dao-api&quot;
&quot;dao-api&quot; -&gt; &quot;domain-model&quot;

&quot;dao-api-impl&quot; -&gt; &quot;dao-api&quot;
&quot;dao-api-impl&quot; -&gt; &quot;domain-model&quot;
&quot;dao-api-impl&quot; -&gt; &quot;persistence-service&quot;
&lt;/pre&gt;&lt;/p&gt;
The nature of the persistence service calls for yet another model, the DAO model. The DAO implementation uses a transformer to transform between the domain model and the DAO model:
&lt;p&gt;&lt;pre&gt;
&quot;dao-api-impl&quot; -&gt; &quot;dao-model&quot;
&quot;dao-api-impl&quot; -&gt; &quot;domain-model-tofrom-dao-model&quot;

&quot;domain-model-tofrom-dao-model&quot; -&gt; &quot;domain-model&quot;
&quot;domain-model-tofrom-dao-model&quot; -&gt; &quot;dao-model&quot;
&lt;/pre&gt;&lt;/p&gt;
That&apos;s it, end of graph:
&lt;p&gt;&lt;pre&gt;
}
&lt;/pre&gt;&lt;/p&gt;
&lt;h4&gt;Delegating the visualization&lt;/h4&gt;
&lt;p&gt;
Then we asked Dottie, our new chief architect, to design the system:
&lt;pre&gt;$ dot -Tps design.dot -o design.ps &amp;&amp; gv design.ps&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;img src=&quot;http://blog.ville.oikarinen.org/design-as-layout.png&quot; alt=&quot;graph&quot;/&gt;
&lt;/p&gt;
&lt;h4&gt;Enjoying the results&lt;/h4&gt;
&lt;p&gt;
Everybody was immediately satisfied (and stopped laughing at the mouseless graphing tool)!
&lt;/p&gt;
&lt;p&gt;
The picture nicely utilizes two dimensions: the layers (REST, domain and DAO) are drawn horizontally, like in a &lt;i&gt;call sequence&lt;/i&gt;. The vertical dimension visualizes dependencies: they flow mostly downwards so the most stable modules are on the bottom.
&lt;/p&gt;
&lt;p&gt;The most important row, the bottom one, is about data. &quot;Good programmers worry about data structures and their relationships&quot; (Torvalds). The middle row consists of service interfaces and model transformers, the &quot;glue&quot;. And in the top row we have the actual logic of the layers.
&lt;/p&gt;
&lt;p&gt;
The interfaces between layers can be seen very clearly: they are the modules in between that both sides depend on. For example, if a new user interface is needed, it just needs to know how to talk to &lt;code&gt;auth-service&lt;/code&gt;, &lt;code&gt;domain-api&lt;/code&gt; and &lt;code&gt;domain-model&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
Another striking discovery is that the whole graph is drawn around the domain model. Good work, Dottie!
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Software_architecture_is_human-only_communication.html</guid>
      <title>Software architecture is human-only communication</title>
      <link>http://blog.ville.oikarinen.org/Software_architecture_is_human-only_communication.html</link>
      <pubDate>Wed, 26 Jan 2011 10:28:00 -0500</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
My definition for software architecture is &lt;i&gt;anything about the code programmers talk with each other using something else than the code&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Most often natural language and graphs. Or hand-waving with or without mouse.
&lt;/p&gt;

&lt;p&gt;
Some architecture is needed, but by this definition, the less the better. Maybe some of today&apos;s architectures are just keywords in a future language?
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Why_modules.html</guid>
      <title>Why modules</title>
      <link>http://blog.ville.oikarinen.org/Why_modules.html</link>
      <pubDate>Tue, 14 Sep 2010 08:55:53 -0400</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
&lt;i&gt;Why split a project into modules?&lt;/i&gt;
To organize the code? Not necessarily a bad idea, but this doesn&apos;t necessarily mean modularization: just use directories to create any of the endless taxonomies possible. Personally I don&apos;t really need this: I open the &lt;a href=&quot;http://blog.ville.oikarinen.org/Traceability_and_entry_points.html&quot;&gt;entry points&lt;/a&gt; (often tests) directly by class name, and other code can be found by navigating, &lt;a href=&quot;http://blog.ville.oikarinen.org/Coding_by_need.html&quot;&gt;by need&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;What&apos;s modularization then if not just subdirectories?&lt;/i&gt;
If the code is compiled and published as one big ball, it&apos;s not modularized, even if it&apos;s internally split into subdirectories. &lt;i&gt;A module is a unit of compilation.&lt;/i&gt; The modules can be compiled individually only, if their dependencies have no cycles. &lt;i&gt;Modularization &lt;a href=&quot;http://blog.ville.oikarinen.org/Splitting_project_to_subprojects_for_easy_dependency_management.html&quot;&gt;enforces&lt;/a&gt; dependency management.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Why bother managing dependencies?&lt;/i&gt;
This sounds like a trivial question, and on some level it is, for most programmers. Still, many projects seem to have dependency problems, so this is really worth thinking through carefully.
&lt;/p&gt;

&lt;p&gt;
When a piece of code needs to be modified, the most likely pieces that need to be modified together with it are the ones that depend on it. So dependency management is about minimizing maintenance costs.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Why does a piece of code need to be modified?&lt;/i&gt;
Another seemingly trivial question. A code needs to be modified to make the software behave in a new way. Now, this seemingly trivial chain of questions has lead us to the core question:
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;How to minimize the cost of implementing new behaviour?&lt;/i&gt;
Ideally we&apos;d like all behaviour defined in one place. Some features are easy to implement like this, but others are more &quot;aspect-like&quot;: they define common behaviour for many different parts of the software. If even that kinds of features can be implemented by modifying one piece of code, then that piece is quite obviously &lt;i&gt;reused&lt;/i&gt; in many places.
&lt;/p&gt;

&lt;p&gt;
So, &lt;i&gt;a module is also a unit of reuse&lt;/i&gt;, and that is in my opinion the most important and often overlooked reason for modularization.
&lt;/p&gt;

&lt;p&gt;
Now, lets take a new look at the first, most superficial reason for modularization: code organization. All taxonomies organize code, but the one based on usable, and ultimately reusable functionality is of any real value. For example, a module may contain many &quot;kinds&quot; of code (a service provides certain functionality together with related data and exceptions). The amount of code can vary very much between modules. If there is such a thing as too small a module, just fix it by adding bloat... right?
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Traceability_and_entry_points.html</guid>
      <title>Traceability and entry points</title>
      <link>http://blog.ville.oikarinen.org/Traceability_and_entry_points.html</link>
      <pubDate>Thu, 9 Sep 2010 09:18:18 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
&lt;i&gt;Traceability&lt;/i&gt; is a kind of &lt;a href=&quot;http://blog.ville.oikarinen.org/Walking_on_red_carpet.html&quot;&gt;red carpet&lt;/a&gt; (or maybe green?) for learning to understand code. Ideally you can trace the code &lt;i&gt;statically&lt;/i&gt;, by reading and ctrl-clicking calls. Polymorphism reduces traceability, but when used wisely, it&apos;s a very acceptable compromise. Inheritance also reduces traceability, but it&apos;s also difficult to use wisely :)
&lt;/p&gt;

&lt;p&gt;
The second best form of traceability is &lt;i&gt;dynamic&lt;/i&gt;: when debugging, you can trace even polymorphic method calls.
&lt;/p&gt;

&lt;p&gt;
But, to be able to set break points for debugging, you need to know the &lt;i&gt;entry points&lt;/i&gt;. The problem with typical enterprise code is that it has a lot of them, and you need to dig through a pile of XMLs and specifications to find them all. Even if you happen to have the container sources at hand, many calls are hidden behind reflection.
&lt;/p&gt;

&lt;p&gt;
Tracing enterprise code statically is virtually impossible, but you can at least &lt;i&gt;list all the entry points&lt;/i&gt; in one place. Create a documentation module that depends on all other modules and write an entry point document in Java. Just print the entry point classes/resources to stdout or something, and maybe even put some explanatory text in between. This file will be the only entry point for static tracing, verified by the compiler.
&lt;/p&gt;

&lt;p&gt;
The long-term solution is of course to reduce the number of entry points. You don&apos;t have to use all those bells and whistles: just add one Plain Old Method Call instead of declaring an interceptor, for example. No more code needed (in fact, Java is even less noisy than XML), but a huge improvement on traceability.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Walking_on_red_carpet.html</guid>
      <title>Walking on red carpet</title>
      <link>http://blog.ville.oikarinen.org/Walking_on_red_carpet.html</link>
      <pubDate>Fri, 7 May 2010 09:09:05 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
I like to think of &lt;a href=&quot;http://blog.ville.oikarinen.org/Coding_by_need.html&quot;&gt;coding by need&lt;/a&gt; as &lt;i&gt;walking on a red carpet&lt;/i&gt; from a problem to its solution. A friendly test failure or compilation error message nicely points to the next problem that needs the programmer&apos;s attention.
&lt;/p&gt;

&lt;p&gt;
It is almost always possible and feasible to drive development with an end-to-end &quot;automated user story&quot; that will stay red until the story is really done. But sometimes the intermediate reds like lower-level unit tests and compilation errors all turn green and leave the programmer wondering what to do next. Searching for the next carpet fragment by reading design documentation.
&lt;/p&gt;

&lt;p&gt;
One way to measure code design is to count the number of gaps in the carpet when implementing a story. In the ideal case the compiler and test messages will guide the programmer from start to finish, and virtually no (other) documentation is needed.
&lt;/p&gt;

&lt;p&gt;
Premature green is another root of all evil.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/A_new_frog_in_a_new_kettle.html</guid>
      <title>A new frog in a new kettle</title>
      <link>http://blog.ville.oikarinen.org/A_new_frog_in_a_new_kettle.html</link>
      <pubDate>Mon, 26 Apr 2010 09:49:39 -0400</pubDate>
      <category>General</category>
      <description>&lt;p&gt;
In December I quit the best and longest job I&apos;ve had (so far). And I haven&apos;t even regretted it :)
&lt;/p&gt;

&lt;p&gt;
So why did I leave &lt;a href=&quot;http://www.sysart.fi&quot;&gt;Sysart&lt;/a&gt; and its inspiring peer community?
&lt;/p&gt;

&lt;p&gt;
New influences. For me, for Sysart, my clients and for my new employer, &lt;a href=&quot;http://www.nokia.com&quot;&gt;Nokia&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Periodical reshuffling of teams keeps influences streaming efficiently. People will learn different things when working on different problems and in different projects. On the other hand, projects will benefit from the different views and fields of expertise each new member brings.
&lt;/p&gt;

&lt;p&gt;
I would have had more to give to the previous project, and I would have learned in it. But I have even more to give to my current project, and it has already treated me with new kinds of juicy problems to learn from. And most probably my replacement in the previous project has improved things to new directions I would have been blind to.
&lt;/p&gt;

&lt;p&gt;
It is said that frogs can be boiled to death because they don&apos;t detect the slow increase of temperature. But a team of frogs can save itself if it invites a fresh member in the water from time to time.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Test_the_zero_case_first.html</guid>
      <title>Test the zero case first</title>
      <link>http://blog.ville.oikarinen.org/Test_the_zero_case_first.html</link>
      <pubDate>Thu, 27 Aug 2009 11:06:34 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
When starting a new &quot;unit of test&quot; (method, interface, module, ...), the first test to write should define its behaviour in the &quot;zero case&quot; i.e. when zero/null/empty goes in, or out.
&lt;/p&gt;

&lt;p&gt;
First, the zero case is often the easiest to implement. Just return &quot;zero&quot;, throw an exception or something like that. And because the feature itself is easy, it is effective at &lt;i&gt;driving&lt;/i&gt; the creation of the new unit, satisfying dependencies in the test environment and otherwise getting started.
&lt;/p&gt;

&lt;p&gt;
Second, the zero case is often a nasty &lt;i&gt;boundary case&lt;/i&gt; that gets overlooked without the test. Sometimes (often with collections) it is automatically OK, but too often it is not.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Post-vacation_cleanup.html</guid>
      <title>Post-vacation cleanup</title>
      <link>http://blog.ville.oikarinen.org/Post-vacation_cleanup.html</link>
      <pubDate>Thu, 27 Aug 2009 10:33:17 -0400</pubDate>
      <category>General</category>
      <description>&lt;p&gt;
This week we finally got sprints running again, now that the whole team has returned and recovered from the vacation.
&lt;/p&gt;

&lt;p&gt;
It is said that it takes weeks to forget work on vacation. I&apos;m pretty good at forgetting (a computer and programming celibacy helps), but it takes weeks to become productive again after the vacation. On the first day at work even typing requires my full attention.
&lt;/p&gt;

&lt;p&gt;
But this is a wonderful opportunity to &lt;i&gt;unlearn&lt;/i&gt; deprecated or even plain wrong patterns of mind and replace them with new, fresh ones.
&lt;/p&gt;

&lt;p&gt;
This year I found a good way to relearn programming and be productive at the same time: I refactored. I was in no shape to write new behaviour (being alone and still half caveman), but there are always suitable tasks on the developer backlog for every skill level.
&lt;/p&gt;

&lt;p&gt;
I started from the &lt;i&gt;bottom...&lt;/i&gt;, with simple refactorings, and gradually advanced &lt;i&gt;...up&lt;/i&gt; into sketching a new framework. I was cured all right...
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Blueberry_bonus.html</guid>
      <title>Blueberry bonus</title>
      <link>http://blog.ville.oikarinen.org/Blueberry_bonus.html</link>
      <pubDate>Thu, 20 Aug 2009 08:05:00 -0400</pubDate>
      <category>General</category>
      <description>&lt;p&gt;
This was a good year for blueberries. The best spot, the biggest loot and the strongest symptoms of &lt;i&gt;mania&lt;/i&gt; ever &lt;b&gt;&lt;code&gt;8D&lt;/code&gt;&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
I didn&apos;t always enjoy berry picking like this. It took a lot of unlearning. My generation doesn&apos;t &lt;i&gt;have to&lt;/i&gt; pick berries.
&lt;/p&gt;

&lt;p&gt;
Every spring when we eat the last berries from the previous summer, I promise myself it&apos;s really OK if I don&apos;t pick new ones. Knowing I &lt;i&gt;will&lt;/i&gt; pick them.
And every time I go to the forest I renew this promise. That every single berry is just a nice &lt;i&gt;bonus&lt;/i&gt;, a side-effect of enjoying the nature. Knowing I &lt;i&gt;will&lt;/i&gt; go mad when I see more blue than green.
&lt;/p&gt;

&lt;p&gt;
In my own programming projects, after each session I try to leave some well-defined little task for the next session. Promising myself it&apos;s really OK if that&apos;s all I get done. The task is often so trivial that it&apos;s amusing to wake the computer for something like that. And I complete the task, and a lot more. Starting is the hard part.
&lt;/p&gt;

&lt;p&gt;
It&apos;s tempting to start requiring the things I know I will do anyway. But that would spoil the &lt;i&gt;fun&lt;/i&gt; and I&apos;d start buying blueberries and feel guilty.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Bottom-up_to_TDD.html</guid>
      <title>Bottom-up to TDD</title>
      <link>http://blog.ville.oikarinen.org/Bottom-up_to_TDD.html</link>
      <pubDate>Tue, 30 Jun 2009 01:48:38 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
In my current client project we have found the following a good way to add new behaviour to our web application.
&lt;/p&gt;

&lt;p&gt;
A test for a web application depends on html details. But often we don&apos;t know these details when starting to write a new feature. So we first make the application output some hard-coded constant html. Sometimes this might even serve as a &lt;i&gt;spike solution&lt;/i&gt; with which to practice some nasty integration, for example, but most of the time the data content really is hard-coded.
&lt;/p&gt;

&lt;p&gt;
When we have manually verified that this one special case looks good, we can write a test for it (encapsulating the html details in a &lt;i&gt;driver&lt;/i&gt; class). The hard-coded values can even be adjusted to match the test expectations so we have really &lt;i&gt;done&lt;/i&gt; one feature, or at least one special case of it.
&lt;/p&gt;

&lt;p&gt;Now, with a working test framework, the the rest is plain old TDD: we just write one test at a time to show that some part of the html output needs to be parameterized.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/If_not_AST,_edit_whole_lines_at_least.html</guid>
      <title>If not AST, edit whole lines at least</title>
      <link>http://blog.ville.oikarinen.org/If_not_AST,_edit_whole_lines_at_least.html</link>
      <pubDate>Tue, 30 Jun 2009 01:45:43 -0400</pubDate>
      <category>Eclipse</category>
      <description>&lt;p&gt;
The more I learn Eclipse, the less I code by processing raw text. More often than not &lt;code&gt;ctrl-space&lt;/code&gt; or &lt;code&gt;ctrl-1&lt;/code&gt; offer just the AST manipulation I need, if I just remember to stop typing and use them.
&lt;/p&gt;

&lt;p&gt;
But there is another level, too, between AST and character: when editing raw text, I edit &lt;i&gt;whole lines&lt;/i&gt; instead of individual characters whenever possible.
&lt;/p&gt;

&lt;p&gt;
For example cutting and pasting whole lines can be done with very few keystrokes: just put the cursor at column 0 and press &lt;code&gt;shift-down&lt;/code&gt; to select some lines before cutting them. Then move the cursor up or down before pasting, again at column 0. Cutting partial lines needs more keystrokes and requires extra formatting. I&apos;ve seen people do a lot of ad-hoc adjusting (every time a different variation!) after each paste.
&lt;/p&gt;

&lt;p&gt;
Line-oriented editing is good for version control, too, because most diff tools compare whole lines. This is another reason why it&apos;s good to add a comma after the last &lt;code&gt;enum&lt;/code&gt; constant: this way adding a new constant is only a one-line diff, since there is no need to modify the previous last line.
&lt;/p&gt;

&lt;p&gt;
This is also one more reason to add a linebreak after the last line!
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Nested_fluent_builder.html</guid>
      <title>Nested fluent builder</title>
      <link>http://blog.ville.oikarinen.org/Nested_fluent_builder.html</link>
      <pubDate>Wed, 31 Dec 2008 09:10:32 -0500</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
Today I published a little article on the Sysart developer site,
&lt;a href=&quot;http://web.sysart.fi/developer/articles:nested_fluent_builder&quot;&gt;Nested fluent builder&lt;/a&gt;,
showing how &lt;a href=&quot;http://blog.ville.oikarinen.org/Fluent_events.html&quot;&gt;fluent events&lt;/a&gt; that form
nested sentences open surprising technological possibilities, as well as being pleasant to the eye.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/TODO_test_and_implement.html</guid>
      <title>TODO test and implement</title>
      <link>http://blog.ville.oikarinen.org/TODO_test_and_implement.html</link>
      <pubDate>Tue, 2 Dec 2008 06:18:17 -0500</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
For a while I have used the following template for auto-generated method stubs in Eclipse:
&lt;/p&gt;
&lt;p&gt;
&lt;pre&gt;
int todoTestAndImplement;
throw new UnsupportedOperationException(&quot;TODO test and implement&quot;);
&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;
The first line makes sure the stub is shown on the problems tab, making it more difficult to forget than items on the tasks tab.
&lt;/p&gt;
&lt;p&gt;
The second line relies on the &lt;i&gt;courage&lt;/i&gt; TDD gives. A runtime exception is really what I want before the new method is really &lt;i&gt;done&lt;/i&gt;.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Fluent_events.html</guid>
      <title>Fluent events</title>
      <link>http://blog.ville.oikarinen.org/Fluent_events.html</link>
      <pubDate>Tue, 28 Oct 2008 08:56:54 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
A few weeks ago me and a colleague were writing a tool that reads a data file (an abstract database description) and executes some sql insertion code for each part of the file. As eager dogfood consumers we chose to use &lt;code&gt;ngr&lt;/code&gt; as the concrete syntax for the file.
&lt;/p&gt;

&lt;p&gt;
We anticipated the data file to be very large, so we got ourselves a story telling that we should be able to stream selected parts of it while building elements from others.
&lt;/p&gt;

&lt;p&gt;
So I modified the &lt;i&gt;ngrease&lt;/i&gt; parser to produce parse events and the element builder to consume them.
&lt;/p&gt;

&lt;p&gt;
Next I started to make the interface easy to use from the database tool. I wanted to avoid the most difficult and laborous part of stream handling, namely &lt;i&gt;state management&lt;/i&gt;. This, combined with the need to delegate parts of the stream
to the existing element builder, lead to a solution where every listener method returns a listener that will handle the next event.
&lt;/p&gt;

&lt;p&gt;
After some more coding I even split the listener interface into several interfaces, roughly one for each production rule of the grammar.
&lt;/p&gt;

&lt;p&gt;
At that point I experienced deja vu: &lt;i&gt;a set of interfaces whose methods all return an interface from the set... I&apos;ve written a fluent interface!&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
Usually fluent interfaces are written for human users, but this had been written for other programs. Well, of course I had to try the interface with Eclipse and its ctrl-space, and while there are better examples of fluent interfaces around, it certainly felt fluent enough for producing a stream of elements by hand.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Entity,_valuetype_and_equals.html</guid>
      <title>Entity, valuetype and equals</title>
      <link>http://blog.ville.oikarinen.org/Entity,_valuetype_and_equals.html</link>
      <pubDate>Fri, 24 Oct 2008 04:11:30 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
There are lots of different classes of equality, but the distinction between &lt;i&gt;entities&lt;/i&gt; and &lt;i&gt;valuetypes&lt;/i&gt; is probably the most important aspect, since it is commonly needed and I have witnessed some misunderstanding with it.
&lt;/p&gt;

&lt;p&gt;
An entity is, by definition, identifiable by its identity. So it&apos;s an error to include any other attribute than the identifier in the &lt;code&gt;equals&lt;/code&gt; method. A person won&apos;t change to another, when the hair colour attribute changes from &quot;brown&quot; to &quot;none&quot;, for example. 
&lt;/p&gt;

&lt;p&gt;
(There may be some technical reasons, like &lt;i&gt;unit of work&lt;/i&gt;, to implement a different &lt;code&gt;equals&lt;/code&gt;, but I see this as a technical layer on top of the &quot;actual&quot; entity.)
&lt;/p&gt;

&lt;p&gt;
A valuetype, on the other hand, is identifiable by all its observable attributes. So it&apos;s an error to omit any of the attributes in the &lt;code&gt;equals&lt;/code&gt; method.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/connect-the-dots,_top_or_bottom.html</guid>
      <title>connect-the-dots, top or bottom</title>
      <link>http://blog.ville.oikarinen.org/connect-the-dots,_top_or_bottom.html</link>
      <pubDate>Tue, 21 Oct 2008 07:19:12 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
I have never really decided whether I like &lt;i&gt;top-down&lt;/i&gt; or &lt;i&gt;bottom-up&lt;/i&gt; more.
&lt;a href=&quot;http://blog.ville.oikarinen.org/Coding_by_need.html&quot;&gt;Coding by need&lt;/a&gt; (coding by intention and TDD) seem to point at top-down. On the other hand, I have been most productive with &lt;i&gt;ngrease&lt;/i&gt; by
&lt;a href=&quot;http://doi.acm.org/10.1145/1297846.1297921&quot;&gt;extracting abstractions&lt;/a&gt; from concrete examples, bottom-up.
&lt;/p&gt;

&lt;p&gt;
Maybe the two approaches have more in common than at least I have thought. I think they are both special cases of a more general principle.
&lt;/p&gt;

&lt;p&gt;
Below is a graph that visualizes the idea. At the top (the &quot;x&quot; on the first line) is a high-level specification. The task is to find a low-level implementation (the &quot;x&quot; on the last line) with a path to the specification so that the implementation satisfies the specification:
&lt;/p&gt;

&lt;p&gt;
&lt;pre&gt;
   . . . x . . . . . .

   . . . . . . . . . .

   . . . . . . . . . .

   . . . . . . . . . .

   . . . . . . . . . .

   . . . . . . . . . .

   . . . . . . x . . .
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;
Sometimes all we have is high-level constraints, and we don&apos;t know or care about low-level details. In that case (or rather, during it) top-down might be the natural way to solve the problem.
&lt;/p&gt;

&lt;p&gt;
On the other hand, if we have low-level constraints, like reusable modules we want to use or some technical legacy requirements, it might be feasible to do bottom-up.
&lt;/p&gt;

&lt;p&gt;
The underlying principle is to &lt;i&gt;connect the dots&lt;/i&gt;, in whatever order feels most appropriate, be it top-down or bottom-up or some combination of them. Maybe even connect-somewhere-in-between if we happen to have some framework-level constraints, for example.
&lt;/p&gt;

&lt;p&gt;
The second diagram shows the problem after both special cases of this principle have been applied for a while and we have a much smaller subproblem to solve:
&lt;/p&gt;

&lt;p&gt;
&lt;pre&gt;
   . . . x . . . . . .
         |
   . . . x . . . . . .
          \
   . . . . x . . . . .

   . . . . . . . . . .

   . . . . . x . . . .
              \
   . . . . . . x . . .
               |
   . . . . . . x . . .
&lt;/pre&gt;
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Defensive_and_offensive_programming.html</guid>
      <title>Defensive and offensive programming</title>
      <link>http://blog.ville.oikarinen.org/Defensive_and_offensive_programming.html</link>
      <pubDate>Fri, 27 Jun 2008 08:12:12 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
For a soccer forward player, 1 success out of 100 attacks may mean a successful match.
&lt;/p&gt;

&lt;p&gt;
But for a defender, only one failure may be all it takes to lose a match.
&lt;/p&gt;

&lt;p&gt;
Many programming tasks are defensive by nature. Errors are best avoided by certain defensive practices like configuration management,
automated tests, encapsulation, static analysis like type checking, idioms and other coding standards that strive for readability etc.
&lt;/p&gt;

&lt;p&gt;
On the other hand, it&apos;s good to recognize the offensive tasks, too, in which the number of failures doesn&apos;t matter as long as there are some successes, too.
It doesn&apos;t matter how many bad languages, frameworks, patterns or designs you try if it helps you to find the ones that work.
&lt;/p&gt;

&lt;p&gt;
Often it&apos;s impossible to score without taking the risk of losing the ball.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/A_file_is_a_target_is_a_property.html</guid>
      <title>A file is a target is a property</title>
      <link>http://blog.ville.oikarinen.org/A_file_is_a_target_is_a_property.html</link>
      <pubDate>Wed, 21 May 2008 08:46:37 -0400</pubDate>
      <category>SCM &amp; process</category>
      <description>&lt;p&gt;
Recently I have adopted a new pattern in my ant scripts to ensure correct dependencies between targets.
&lt;/p&gt;
   
&lt;p&gt;
Whenever a target references another file, it does it using a property. And the property is defined in the target that generates the file.
This way it is impossible to access the file without properly &lt;i&gt;depending on it as a target&lt;/i&gt;.
&lt;/p&gt;
   
&lt;p&gt;
If a target has a corresponding &quot;status&quot; target that checks the uptodate status, the property must be defined in the status target.
Otherwise the property won&apos;t be set when the target is uptodate.
&lt;/p&gt;
   
&lt;p&gt;
However, ant causes an annoying practical problem by silently ignoring an invalid property reference and using the reference itself as the literal path.
So, while this pattern ensures that missing dependencies are caught, the feedback isn&apos;t always very helpful or even immediate.
&lt;/p&gt;
   
&lt;p&gt;
An example:
&lt;/p&gt;   

&lt;hr/&gt;

&lt;p&gt;
&lt;pre&gt;
&amp;lt;project name=&quot;demo&quot; default=&quot;test-report&quot;&gt;

  &amp;lt;target
    name=&quot;test-report&quot;
    depends=&quot;
      classes,
      test-classes,
      targetdir
    &quot;
  &gt;
    &amp;lt;echo message=&quot;mock running the tests&quot;/&gt;
    &amp;lt;echo message=&quot;  referencing ${test-classes}&quot;/&gt;
    &amp;lt;echo message=&quot;  and ${classes}&quot;/&gt;
  &amp;lt;/target&gt;

  &amp;lt;target
    name=&quot;test-classes&quot;
    depends=&quot;
      classes,
      targetdir,
      test-classes-status
    &quot;
    unless=&quot;test-classes-is-uptodate&quot;
  &gt;
    &amp;lt;delete dir=&quot;${test-classes}&quot;/&gt;
    &amp;lt;echo message=&quot;Mock creating ${test-classes}&quot;/&gt;
    &amp;lt;echo message=&quot;  referencing ${classes}&quot;/&gt;
    &amp;lt;mkdir dir=&quot;${test-classes}&quot;/&gt;
    &amp;lt;touch file=&quot;${test-classes-timestamp}&quot;/&gt;
  &amp;lt;/target&gt;

  &amp;lt;target
    name=&quot;test-classes-status&quot;
    depends=&quot;
      classes-status,
      targetdir
    &quot;
  &gt;
    &amp;lt;property
      name=&quot;test-classes&quot;
      value=&quot;${targetdir}/test-classes&quot;
    /&gt;
    &amp;lt;property
      name=&quot;test-classes-timestamp&quot;
      value=&quot;${targetdir}/test-classes.timestamp&quot;
    /&gt;
    &amp;lt;uptodate
      property=&quot;test-classes-is-uptodate&quot;
      targetfile=&quot;${test-classes-timestamp}&quot;
    &gt;
       &amp;lt;srcfiles dir=&quot;tests&quot; includes=&quot;**/*&quot;/&gt;
       &amp;lt;srcfiles file=&quot;${classes-timestamp}&quot;/&gt;
    &amp;lt;/uptodate&gt;
  &amp;lt;/target&gt;

  &amp;lt;target
    name=&quot;classes&quot;
    depends=&quot;
      targetdir,
      classes-status
    &quot;
    unless=&quot;classes-is-uptodate&quot;
  &gt;
    &amp;lt;delete dir=&quot;${classes}&quot;/&gt;
    &amp;lt;echo message=&quot;Mock creating ${classes}&quot;/&gt;
    &amp;lt;mkdir dir=&quot;${classes}&quot;/&gt;
    &amp;lt;touch file=&quot;${classes-timestamp}&quot;/&gt;
  &amp;lt;/target&gt;

  &amp;lt;target
    name=&quot;classes-status&quot;
    depends=&quot;
      targetdir
    &quot;
  &gt;
    &amp;lt;property
      name=&quot;classes&quot;
      value=&quot;${targetdir}/classes&quot;
    /&gt;
    &amp;lt;property
      name=&quot;classes-timestamp&quot;
      value=&quot;${targetdir}/classes.timestamp&quot;
    /&gt;
    &amp;lt;uptodate
      property=&quot;classes-is-uptodate&quot;
      targetfile=&quot;${classes-timestamp}&quot;
    &gt;
       &amp;lt;srcfiles dir=&quot;src&quot; includes=&quot;**/*&quot;/&gt;
    &amp;lt;/uptodate&gt;
  &amp;lt;/target&gt;

  &amp;lt;target
    name=&quot;targetdir&quot;
  &gt;
    &amp;lt;property name=&quot;targetdir&quot; value=&quot;${basedir}/target&quot;/&gt;
    &amp;lt;mkdir dir=&quot;${targetdir}&quot;/&gt;
  &amp;lt;/target&gt;

&amp;lt;/project&gt;
&lt;/pre&gt;
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Comparison_of_UIs_as_languages.html</guid>
      <title>Comparison of UIs as languages</title>
      <link>http://blog.ville.oikarinen.org/Comparison_of_UIs_as_languages.html</link>
      <pubDate>Wed, 26 Mar 2008 08:27:21 -0400</pubDate>
      <category>Metaprogramming</category>
      <description>&lt;p&gt;
Communication uses languages. Communication involving computers (human-computer and computer-computer) is no exception.
&lt;/p&gt;

&lt;p&gt;
The languages that are used at the &quot;lowest level&quot; are usually called programming languages: the machine language on the bottom, and
general purpose languages, GPLs, right above it.
This blog analyzes &quot;higher level&quot; languages, usually called &lt;i&gt;user interfaces&lt;/i&gt; or &lt;i&gt;domain-specific languages&lt;/i&gt;, using the following attributes:
&lt;ul&gt;
&lt;li&gt;Expressiveness: a measure of how well the language covers ideas and concepts of its domain i.e. how &quot;much&quot; can be said in the language.&lt;/li&gt;
&lt;li&gt;Ergonomics: a measure of how &quot;easy&quot; it is to use the language. An ergonomic language has little noise (high &quot;semantic density&quot;) and redundancy.&lt;/li&gt;
&lt;li&gt;Integratability: a measure of how easy it is to use the language from other languages.&lt;/li&gt;
&lt;li&gt;Implementability: a measure of how easy it is to implement such a language.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;h4&gt;Internal textual languages (APIs)&lt;/h4&gt;

&lt;h5&gt;Internal API&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;All functionality is implemented by this so no other language can be more expressive.&lt;/li&gt;
&lt;li&gt;Inherits unfiltered noise from the implementation GPL, which may reduce ergonomics significantly.&lt;/li&gt;
&lt;li&gt;Integration is possible but laborous and introduces hard dependencies on volatile implementation details.&lt;/li&gt;
&lt;li&gt;As an essential part of every program requires no extra implementation effort.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Public API&lt;/h5&gt;
   
&lt;ul&gt;
&lt;li&gt;Some unsafe or otherwise unwanted expressiveness is removed when publishing an API; something essential may be lost, too.&lt;/li&gt;
&lt;li&gt;As a tidier version of the internal API this language may be somewhat less noisy, but not much.&lt;/li&gt;
&lt;li&gt;Integration is easier and more robust than using the internal API, since accidental details are hidden. The type system of the GPL often
makes API-level integration the preferred form of integration, but only within the same GPL.&lt;/li&gt;
&lt;li&gt;Implementation is usually quite straightforward, but requires some &quot;distilling&quot; to make a good API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;API bindings for another GPL&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;As another version of the public API this language should be as expressive.&lt;/li&gt;
&lt;li&gt;Depending on the new GPL, this language may be either more or less ergonomic than the original public API. And since this
language is probably implemented later, it might be possible to learn from the mistakes of the original public API.&lt;/li&gt;
&lt;li&gt;Increasing integratability is the motivation for creating this language, but this way it happens one GPL at a time.&lt;/li&gt;
&lt;li&gt;Implementation is straightforward but dull and technical.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;External textual languages&lt;/h4&gt;

&lt;h5&gt;A language based on the Command Line Interface framework&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Expressiveness may be reduced due to the restrictions of the framework: only one line can be used, and its length may be restricted.&lt;/li&gt;
&lt;li&gt;The framework (shell) introduces some noise, like whitespace escaping, but this is often relatively minimal.&lt;/li&gt;
&lt;li&gt;The shell makes it easy to generate sentences for this language so integration is easy.&lt;/li&gt;
&lt;li&gt;CLI argument parsing is usually easy to implement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;A language based on some other metalanguage&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Proper metalanguages don&apos;t restrict expressiveness.&lt;/li&gt;
&lt;li&gt;The metalanguage may introduce some noise, but it is usually on the concrete syntax level.&lt;/li&gt;
&lt;li&gt;A common metalanguage makes it easier to integrate languages. Furthermore, if the producers and consumers of this language utilize streams instead of files, integration is
very easy and powerful via pipes.&lt;/li&gt;
&lt;li&gt;Implementation requires work on the abstract syntax and semantics level, but the metalanguage helps a lot.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;A fully custom language&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;There is no restriction for expressiveness.&lt;/li&gt;
&lt;li&gt;This is potentially the most ergonomic language, since its design can be completely dictated by domain-specific concerns.&lt;/li&gt;
&lt;li&gt;The lack of a common metalanguage or framework reduces integratability somewhat, but textual format helps a lot.&lt;/li&gt;
&lt;li&gt;This is the most laborous textual language to implement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Non-textual languages&lt;/h4&gt;

&lt;h5&gt;GUI&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;This is usually the least expressive language, since many ideas cannot be expressed as gestures.&lt;/li&gt;
&lt;li&gt;If the domain is expressible as gestures, the mapping is usually very intuitive and ergonomic. The gesture metalanguage introduces certain noise, though, and
long sentences are laborous and slow to express.&lt;/li&gt;
&lt;li&gt;Integration is often virtually impossible: GUI gestures are difficult to automate, manipulate and reroute reliably.&lt;/li&gt;
&lt;li&gt;Certain &quot;standard&quot; solutions may be relatively easy to implement, but often GUI tweaking takes a lot of time. One reason may be that there are often many stakeholders
with their subjective opinions about good GUI design.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Other languages&lt;/h5&gt;

&lt;p&gt;
Speech interface is a variation of a custom textual language, but not yet practical to implement. It&apos;s interesting to see what other language types emerge.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Where,_what_and_how,_in_that_order.html</guid>
      <title>Where, what and how, in that order</title>
      <link>http://blog.ville.oikarinen.org/Where,_what_and_how,_in_that_order.html</link>
      <pubDate>Tue, 19 Feb 2008 09:24:31 -0500</pubDate>
      <category>SCM &amp; process</category>
      <description>&lt;p&gt;
Before a client can tell us what he wants done, he must tell &lt;i&gt;where&lt;/i&gt; (the version of the &quot;bin&quot;) he wants it done.
&lt;/p&gt;

&lt;p&gt;
Then he tells what he wants (This is &lt;i&gt;just&lt;/i&gt; specifications, stories, communication, analysis etc).
&lt;/p&gt;

&lt;p&gt;
Before we can do it, we must know &lt;i&gt;where&lt;/i&gt; (the version of the &quot;src&quot;) it should be done.
&lt;/p&gt;

&lt;p&gt;
Then we do it (This is &lt;i&gt;just&lt;/i&gt; languages, architecture, design, methodologies etc)
&lt;/p&gt;

&lt;p&gt;
After we have done it, we must get a new &quot;bin&quot; from the &quot;src&quot; and deliver it to the client.
&lt;/p&gt;

&lt;p&gt;
Afterwards we must be able to track who requested what (&lt;i&gt;where&lt;/i&gt; is the request?) to &lt;i&gt;where&lt;/i&gt;, how it was done (&lt;i&gt;where&lt;/i&gt; is the diff?) and what got delivered to the client (&lt;i&gt;where&lt;/i&gt; is the &quot;bin&quot; and a recipe to create it again?).
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;
Software Configuration Management is a reliable mapping between what a client sees and what a programmer sees.
&lt;/i&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Learning_by_overdoing.html</guid>
      <title>Learning by overdoing</title>
      <link>http://blog.ville.oikarinen.org/Learning_by_overdoing.html</link>
      <pubDate>Fri, 15 Feb 2008 08:45:19 -0500</pubDate>
      <category>Agile</category>
      <description>&lt;p&gt;
Information Technology, the traditional view: automated, fast, repeatable, scalable, universal. Interconnected concepts and derivation of new ones.
&lt;/p&gt;
   
&lt;p&gt;
Information Technology, the agile view: simple, concrete, immediate, temporary, specific.
&lt;/p&gt;

&lt;p&gt;   
&lt;i&gt;
paper and pencil, story rewrites.&lt;br/&gt;
a squaking rubber toy, speech rights&lt;br/&gt;
yellow stickies, group to plan&lt;br/&gt;
storypoint totals, computed by man&lt;br/&gt;
&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
After years of over-engineering, rigid analysis and technological overoptimism,
this new lowtech movement is a refreshing antithesis that helps us concentrate on the essential.
&lt;i&gt;It&apos;s not about technology, it&apos;s about getting things done.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
Still, haven&apos;t we already learnt the lesson? Could we move on and apply it to our actual profession?
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;
We are selling automation so it&apos;s best we get back into using it ourselves.
&lt;/i&gt;
If low tech solutions really work better, haven&apos;t we failed as creators of helpful technology?
&lt;/p&gt;

&lt;p&gt;
If we delay the adoption of scalable solutions, are we ready when the time comes they are really needed?
&lt;/p&gt;

&lt;p&gt;
I admit I am a repeatability and automation geek. I hate having to remember things. I feel uncomfortable when I do something I know I cannot repeat.
Still, I believe that by consistently trying to use scalable tools before falling back to mouse-clicking and paper-tossing, I increase or at least maintain my skills so I&apos;m at my full
capacity whenever they are needed.
&lt;/p&gt;

&lt;p&gt;
I&apos;m suffering some constant inconvenience in hope to minimize inconvenience with requirements worse than O(1). And the constant is decreasing all the time :)
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/The_aesthetics_of_complex_simplicity.html</guid>
      <title>The aesthetics of complex simplicity</title>
      <link>http://blog.ville.oikarinen.org/The_aesthetics_of_complex_simplicity.html</link>
      <pubDate>Wed, 13 Feb 2008 08:58:31 -0500</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
Last week I bought two excellent books, &lt;i&gt;The Art of the Snowflake: A Photographic Album&lt;/i&gt; by Kenneth Libbrecht
and &lt;i&gt;Whisky Classified: choosing single malts by flavour&lt;/i&gt; by David Wishart.
&lt;/p&gt;
   
&lt;p&gt;
I soon realized that it wasn&apos;t a coincidence I chose these seemingly different books:
Both describe a complex and aesthetically pleasing result
from simple ingredients and a sensitive, even chaotic process.
&lt;/p&gt;
   
&lt;p&gt;
Still, in both cases the chaos is wonderfully under control:
Each snowflake is unique, but its arms are almost identical.
Each distillery produces a unique whisky, but its production is amazinly uniform.
&lt;/p&gt;
   
&lt;p&gt;
If controlled chaos and simplicity of fundamentals are not aesthetically pleasing to a programmer, then what is.
&lt;p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Hierarchy_is_not_a_property.html</guid>
      <title>Hierarchy is not a property</title>
      <link>http://blog.ville.oikarinen.org/Hierarchy_is_not_a_property.html</link>
      <pubDate>Mon, 11 Feb 2008 06:42:06 -0500</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
There are many cases where an item contains a property that defines its location inside a hierarchy:
&lt;ul&gt;
&lt;li&gt;In HTML a header element defines its own location in the (assumed) hierarchy of headers: an H1 header is &quot;higher&quot; than an H2 header.&lt;/li&gt;
&lt;li&gt;Latex sections also define their own level: there are sections, subsections and subsubsections.&lt;/li&gt;
&lt;li&gt;Java source files define their own package, and the information is usually redundantly reflected in the directory hierarchy, too.&lt;/li&gt;
&lt;/ul&gt;
   
&lt;p&gt;
This is an antipattern. The location in a hierarchy is not a property of the contained object.
Instead, &lt;i&gt;the location in a hierarchy is simply defined by the location in a hierarchy.&lt;/i&gt;
&lt;/p&gt;
&lt;p&gt;
If the parent-child relationship is defined &lt;i&gt;only&lt;/i&gt; by an attribute in the child object, this is not a problem. One-to-many relationships in SQL are typically
defined like this. (Technically references are often stored in both ends of a relationship, especially in volatile run-time objects, but this is just an optimization, hidden under the hood.)      
&lt;/p&gt;
&lt;p&gt;
The problem in all the examples above is that the hierarchy is defined &lt;i&gt;both&lt;/i&gt; by an attribute of the child &lt;i&gt;and&lt;/i&gt; the location of the child 
in relation to other objects. This redundancy causes problems when the structure needs to be changed: the object needs to be both moved and changed.
&lt;/p&gt;
   
&lt;p&gt;
The article language I wrote in &lt;i&gt;ngrease&lt;/i&gt; is an abstraction of HTML and Latex, but in it sections are defined as a nested hierarchy. This makes
writing and restructuring painless, especially if each section is defined in a separate file, included by its parent: Only &lt;i&gt;one layer thinking&lt;/i&gt; is needed when writing
a section, and the article can be restructured simply by moving section references (the &quot;include&quot; expressions), without any need to touch the referenced section
definitions.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Startup_scripts_without_a_PRODUCT_HOME_variable.html</guid>
      <title>Startup scripts without a PRODUCT_HOME variable</title>
      <link>http://blog.ville.oikarinen.org/Startup_scripts_without_a_PRODUCT_HOME_variable.html</link>
      <pubDate>Tue, 5 Feb 2008 07:23:38 -0500</pubDate>
      <category>Scripting</category>
      <description>&lt;p&gt;
Another old and simple subject I should have posted a long time ago:
&lt;/p&gt;

&lt;p&gt;
A typical command line tool implemented in Java
contains a startup script (actually many of them - it&apos;s &lt;i&gt;run everywhere&lt;/i&gt; only once you get it running...) for configuring and starting a JVM for the tool.
&lt;/p&gt;

&lt;p&gt;
Some tools require a &lt;tt&gt;PRODUCT_HOME&lt;/tt&gt; environment variable to be able to find the classes and other files of the tool.
&lt;/p&gt;

&lt;p&gt;
This isn&apos;t necessary, the script can detect its own location and deduce the tool location from it.
&lt;/p&gt;

&lt;p&gt;
Assuming the startup script is under a subdirectory of &lt;tt&gt;PRODUCT_HOME&lt;/tt&gt;, for example &lt;tt&gt;bin&lt;/tt&gt;, &lt;tt&gt;PRODUCT_HOME&lt;/tt&gt; can be deduced like this:
&lt;/p&gt;

&lt;p&gt;
First the bash version:
&lt;/p&gt;

&lt;p&gt;
&lt;pre&gt;
SCRIPT_HOME=$(dirname &quot;$0&quot;)
PRODUCT_HOME=&quot;$SCRIPT_HOME/..&quot;
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;
And the Windows version, as documented by
&lt;a href=&quot;http://weblogs.asp.net/whaggard/archive/2005/01/28/get-directory-path-of-an-executing-batch-file.aspx&quot;&gt;puzzlehacker&lt;/a&gt;, among others;
I don&apos;t know which Windows versions support this (and luckily it&apos;s not really my problem):
&lt;/p&gt;

&lt;p&gt;
&lt;pre&gt;
set SCRIPT_HOME=%~dp0
set PRODUCT_HOME=%SCRIPT_HOME%\..
&lt;/pre&gt;
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Subversion_and_the_direction_of_merges.html</guid>
      <title>Subversion and the direction of merges</title>
      <link>http://blog.ville.oikarinen.org/Subversion_and_the_direction_of_merges.html</link>
      <pubDate>Wed, 30 Jan 2008 09:20:07 -0500</pubDate>
      <category>SCM &amp; process</category>
      <description>&lt;p&gt;
An obvious fact (by definition) is that fewer changes are wanted in a stable (release) branch than in an instable (development) branch.
&lt;/p&gt;
   
&lt;p&gt;
Another fact is that changes (most probably bug fixes) made in a stable branch are often wanted in more instable branches, too, if applicable. And most changes in 
instable branches are not wanted in stable branches.
&lt;/p&gt;
   
&lt;p&gt;
The third fact is that when merging, subversion cannot detect changes that originate from the target branch of the merge (and have been earlier merged in the opposite direction). These changes are shown as conflicts. This probably applies to many other VCS&apos;s, too.
&lt;/p&gt;
   
&lt;p&gt;
The implication is that merging is least painful, when each change is first made to the most stable branch it is wanted in. Then it is merged in the direction of
instability.                           
&lt;/p&gt;
   
&lt;p&gt;
Of course sometimes merging is needed in the wrong direction, too, but it should be avoided as an unwanted exception.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Eagerly_find_dish_machines_to_empty.html</guid>
      <title>Eagerly find dish machines to empty</title>
      <link>http://blog.ville.oikarinen.org/Eagerly_find_dish_machines_to_empty.html</link>
      <pubDate>Wed, 30 Jan 2008 08:15:02 -0500</pubDate>
      <category>SCM &amp; process</category>
      <description>&lt;p&gt;
In general it&apos;s wise to be lazy. &lt;i&gt;Don&apos;t do it (yet)&lt;/i&gt;, &lt;i&gt;You Ain&apos;t Gonna Need It&lt;/i&gt;, &lt;i&gt;Don&apos;t Repeat Yourself&lt;/i&gt; etc.
&lt;/p&gt;

&lt;p&gt;
But the exception is &lt;i&gt;tasks that open new ways to be lazy&lt;/i&gt;. Or, put the other way, tasks that cause you more work if delayed. 
&lt;/p&gt;

&lt;p&gt;
Emptying the dish machine is one such task: if you delay it, you&apos;ll start piling dirty dishes, and before you know, you don&apos;t know where to put things. You&apos;ve got a mess that generates more mess.
&lt;/p&gt;

&lt;p&gt;
I think most SCM-related tasks belong to this category. Solving even a small problem in SCM gives easily more leverage than a moderate design refactoring.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Race_driving_stories.html</guid>
      <title>Race driving stories</title>
      <link>http://blog.ville.oikarinen.org/Race_driving_stories.html</link>
      <pubDate>Mon, 3 Dec 2007 03:54:57 -0500</pubDate>
      <category>Agile</category>
      <description>&lt;p&gt;
Next time I get a heap of pseudo-formal structured specification documents instead of user stories telling what the user really wants, I might try a lesson from a field older than ours:
&lt;/p&gt;
&lt;p&gt;
&lt;i&gt;
Most good engineers don&apos;t want a technical explanation from the driver.
They want a detailed explanation of how the car feels.
So, learn how to tell what the car is doing, not why.
This will make you a better race driver.
&lt;/i&gt;
&lt;br/&gt;
(From &quot;Professional Race Driving Techniques&quot; by Ross Bentley, page 10)
&lt;/p&gt;
&lt;p&gt;
Sounds like &quot;As a &lt;u&gt;driver&lt;/u&gt; I want &lt;u&gt;my car to...&lt;/u&gt;&quot; doesn&apos;t it :)
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/The_art_of_getting_rid_of_art.html</guid>
      <title>The art of getting rid of art</title>
      <link>http://blog.ville.oikarinen.org/The_art_of_getting_rid_of_art.html</link>
      <pubDate>Tue, 9 Oct 2007 06:51:55 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
A good programmer practices the art of formalizing his art into a science.
&lt;/p&gt;
&lt;p&gt;
I hate the art part enough to try to get rid of it. But at the same time I love the art and hope we&apos;ll never get there.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Missing_Person.html</guid>
      <title>Missing Person</title>
      <link>http://blog.ville.oikarinen.org/Missing_Person.html</link>
      <pubDate>Fri, 5 Oct 2007 06:15:05 -0400</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
This is a pattern I have discovered surprisingly often (you can also replace Patient with Customer and Doctor with Employee etc):
&lt;/p&gt;

&lt;p&gt;
&lt;pre&gt;
public interface Patient {

  String getFirstName();

  String getLastName();

  String getAddress();

  // ...

}

public interface Doctor {

  String getFirstName();

  String getLastName();

  String getAddress();

  // ...

}
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;
Either doctors are very healthy, or they are so shy they want another identity as patients :)
&lt;/p&gt;

&lt;p&gt;
Of course extra complexity isn&apos;t good either, but I have seen more often reason to extract the missing Person entity here than not to.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Java_package_hierarchy_is_only_in_the_name.html</guid>
      <title>Java package hierarchy is only in the name</title>
      <link>http://blog.ville.oikarinen.org/Java_package_hierarchy_is_only_in_the_name.html</link>
      <pubDate>Fri, 21 Sep 2007 09:12:42 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
One of the minor annoyances of Java is that a package and its parent are as foreign to each other than any other pair of packages.
&lt;/p&gt;
&lt;p&gt;
In practice this means that if I want to split a package (module) into subpackages (why wouldn&apos;t I?), all interfaces meant for &quot;internal communication&quot; inside the module must be visible to other packages as well.
&lt;/p&gt;
&lt;p&gt;
A related problem is that there is no such thing as package private interfaces. Sure, the interface itself can be package private, but the method implementations must be public. So if I use a package private interface inside a package, a class unfortunate enough to be public and implement this internal interface must publish the supposedly internal interface methods.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/My_shell_scripts_start_to_get_infected_with_meta.html</guid>
      <title>My shell scripts start to get infected with meta</title>
      <link>http://blog.ville.oikarinen.org/My_shell_scripts_start_to_get_infected_with_meta.html</link>
      <pubDate>Mon, 6 Aug 2007 08:27:41 -0400</pubDate>
      <category>Metaprogramming</category>
      <description>&lt;p&gt;
Recently I have discovered that my metaprogramming efforts have started to infect (&lt;a href=&quot;http://blog.ville.oikarinen.org/You_are_what_you_feed_your_brain_with.html&quot;&gt;you are what you feed your brain with&lt;/a&gt;) my way of writing shell scripts.
&lt;/p&gt;
&lt;p&gt;
Earlier it felt dirty and &quot;non-unixy&quot; to generate temporary shell scripts. I felt pride every time I managed to avoid it using xargs, find -exec, functions, loops etc.
&lt;/p&gt;
&lt;p&gt;
Now it feels quite good to process a set of files by generating separate commands for each file, piping them first to less for manual reviewing and finally to a new bash for execution. And it feels even better to manipulate the script with sed.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Java_method_call_performance.html</guid>
      <title>Java method call performance</title>
      <link>http://blog.ville.oikarinen.org/Java_method_call_performance.html</link>
      <pubDate>Tue, 19 Jun 2007 03:54:41 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
Maybe this old performance test of mine interests someone.
&lt;/p&gt;
&lt;p&gt;
Here are the results using Sun JDK 1.4.2_09 and Windows XP:
&lt;/p&gt;

&lt;pre&gt;
Task array init took 3656ms.
Task direct took 4110ms.
Task method call took 4078ms.
Task method call with parametrized addition took 4016ms.
Task method call with parametrized addition and original took 4079ms.
Task method call through interface took 15687ms.
Task method call through final ref to interface (final impl) took 15531ms.
Task method call through final ref to final class took 4219ms.
&lt;/pre&gt;

&lt;p&gt;
And here&apos;s the test:
&lt;/p&gt;

&lt;pre&gt;
package methodcallperformance;

public class MethodCallPerformanceDemo {

    protected static final int COUNT = 1000000;

    protected static int[] data = new int[COUNT];

    private static void init() {
        for (int i = 0; i &lt; COUNT; i++) {
            data[i] = i;
        }
    }

    public static void main(String[] args) {
        time(&quot;array init&quot;, new Runnable() {

            public void run() {
                init();
            }
        });

        time(&quot;direct&quot;, new Runnable() {

            public void run() {
                for (int i = 0; i &lt; COUNT; i++) {
                    data[i] = data[i] + 2;
                }
            }
        });

        time(&quot;method call&quot;, new Runnable() {

            public void run() {
                for (int i = 0; i &lt; COUNT; i++) {
                    increase(i);
                }
            }

            private void increase(int i) {
                data[i] = data[i] + 2;
            }
        });

        time(&quot;method call with parametrized addition&quot;, new Runnable() {

            public void run() {
                for (int i = 0; i &lt; COUNT; i++) {
                    increase(i, 2);
                }
            }

            private void increase(int i, int addition) {
                data[i] = data[i] + addition;
            }
        });

        time(&quot;method call with parametrized addition and original&quot;,
                new Runnable() {

                    public void run() {
                        for (int i = 0; i &lt; COUNT; i++) {
                            increase(i, data[i], 2);
                        }
                    }

                    private void increase(int i, int original, int addition) {
                        data[i] = original + addition;
                    }
                });

        time(&quot;method call through interface&quot;, new Runnable() {

            public void run() {
                for (int i = 0; i &lt; COUNT; i++) {
                    data[i] = calc.calculate(data[i]);
                }
            }
        });

        // this *could* be optimized by the JVM but Sun jdk 1.4 doesn&apos;t:
        time(&quot;method call through final ref to interface (final impl)&quot;,
                new Runnable() {

                    public void run() {
                        for (int i = 0; i &lt; COUNT; i++) {
                            data[i] = finalCalc.calculate(data[i]);
                        }
                    }
                });

        time(&quot;method call through final ref to final class&quot;, new Runnable() {

            public void run() {
                for (int i = 0; i &lt; COUNT; i++) {
                    data[i] = finalCalcImpl.calculate(data[i]);
                }
            }
        });

    }

    public static Calculator calc = new CalculatorImpl();

    public static final Calculator finalCalc = new CalculatorFinalImpl();

    public static final CalculatorFinalImpl finalCalcImpl = new CalculatorFinalImpl();

    public static interface Calculator {

        int calculate(int i);

    }

    public static class CalculatorImpl implements Calculator {

        public int calculate(int i) {
            return i + 2;
        }

    }

    public static final class CalculatorFinalImpl implements Calculator {

        public int calculate(int i) {
            return i + 2;
        }

    }

    private static void time(String name, Runnable runnable) {
        init();
        // first run a warmup to give JIT a chance:
        runTaskManyTimes(runnable);
        // then lets measure:
        long t1 = System.currentTimeMillis();
        runTaskManyTimes(runnable);
        long t2 = System.currentTimeMillis();
        System.out.println(&quot;Task &quot; + name + &quot; took &quot; + (t2 - t1) + &quot;ms.&quot;);
    }

    private static void runTaskManyTimes(Runnable runnable) {
        for (int i = 0; i &lt; 500; i++) {
            runnable.run();
        }
    }

}
&lt;/pre&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Search_keywords_and_urls_as_a_textual_user_interface.html</guid>
      <title>Search keywords and urls as a textual user interface</title>
      <link>http://blog.ville.oikarinen.org/Search_keywords_and_urls_as_a_textual_user_interface.html</link>
      <pubDate>Mon, 28 May 2007 06:15:12 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
Maybe &lt;a href=&quot;http://catb.org/~esr/writings/unix-koans/gui-programmer.html&quot;&gt;this philosophy&lt;/a&gt; gets a wider acceptance when filesystems are something like &lt;a href=&quot;http://www.namesys.com/whitepaper.html&quot;&gt;this.&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
Imagine having to use only portals for web surfing...
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/ngrease_0.1.0_released.html</guid>
      <title>ngrease 0.1.0 released</title>
      <link>http://blog.ville.oikarinen.org/ngrease_0.1.0_released.html</link>
      <pubDate>Wed, 2 May 2007 06:34:29 -0400</pubDate>
      <category>Metaprogramming</category>
      <description>&lt;p&gt;
Yesterday I finally made the first release of my pet project, the
&lt;a href=&quot;http://sourceforge.net/projects/ngrease&quot;&gt;ngrease&lt;/a&gt; metalanguage.
&lt;/p&gt;
&lt;p&gt;
Read the
&lt;a href=&quot;http://ngrease.sourceforge.net/introduction.html&quot;&gt;Introduction to ngrease&lt;/a&gt;
for more information.
&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Optimizing_the_SW_development_algorithm.html</guid>
      <title>Optimizing the SW development algorithm</title>
      <link>http://blog.ville.oikarinen.org/Optimizing_the_SW_development_algorithm.html</link>
      <pubDate>Fri, 3 Nov 2006 11:54:25 -0500</pubDate>
      <category>SCM &amp; process</category>
      <description>&lt;p&gt;
&lt;i&gt;Warning: this article contains simplifications so read on with care :)&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
This is a sketch of an algorithm for the test driven sw development process:
&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
while not client.isHappy()
  specification = client.writeSpecification()
  if specification.isExecutable()
    executableSpecification = specification
  else
    executableSpecification =  programmer.formalize(specification)
    // executableSpecification must be readable by client
    client.verify(executableSpecification)

  if productionSystem.canExecute(executableSpecification)
    productionSystem.add(executableSpecification)
  else
    allTests.add(executableSpecification)

    while not testFramework.doAllTestsPass(allTests)
      productionSystem = programmer.code(productionSystem, allTests)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;
How could this process be optimized? Here are some suggestions, from the easiest to the most difficult:
&lt;/p&gt;

&lt;p&gt;
Introduce an executable language for expressing specifications by example. Now the programmer isn&apos;t needed to write the specification, and the client doesn&apos;t need to verify his/her own creation:
&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
while not client.isHappy()
  executableSpecification = client.writeSpecification()

  if productionSystem.canExecute(executableSpecification)
    productionSystem.add(executableSpecification)
  else
    allTests.add(executableSpecification)

    while not testFramework.doAllTestsPass(allTests)
      productionSystem = programmer.code(productionSystem, allTests)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;
If the problem happens to be one of those that are difficult to specify formally, this is the best we can do. Otherwise, we have a formal and executable 
specification, so the production system can use the specification as 
such:
&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
while not client.isHappy()
  executableSpecification = client.writeSpecification()
  productionSystem.add(executableSpecification)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;
Whoops:
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;Warning: unused variable: programmer&lt;/code&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Usage_driven_interface,_test_driven_semantics.html</guid>
      <title>Usage driven interface, test driven semantics</title>
      <link>http://blog.ville.oikarinen.org/Usage_driven_interface,_test_driven_semantics.html</link>
      <pubDate>Tue, 13 Jun 2006 07:29:37 -0400</pubDate>
      <category>Art of programming</category>
      <description>&lt;h5&gt;The problem&lt;/h5&gt;

&lt;p&gt;
I need a class &lt;i&gt;A&lt;/i&gt; to provide service &lt;i&gt;a&lt;/i&gt; for me. First I create &lt;i&gt;ATest&lt;/i&gt; and
specify some of the wanted behaviour of &lt;i&gt;A&lt;/i&gt; there. Then I start
implementing &lt;i&gt;A&lt;/i&gt;. All is well, I let &lt;i&gt;ATest&lt;/i&gt; drive all the development.
&lt;/p&gt;
&lt;p&gt;
Then, during the implementation of &lt;i&gt;A&lt;/i&gt; I start to realize that in order to
fulfill its task &lt;i&gt;A&lt;/i&gt; needs to delegate a subtask to a new class, &lt;i&gt;B&lt;/i&gt;. Now,
it&apos;s clearly the implementation of &lt;i&gt;A&lt;/i&gt; that drives the development of &lt;i&gt;B&lt;/i&gt;.
But, according to the principle of test driven development, shouldn&apos;t I
first create &lt;i&gt;BTest&lt;/i&gt; that drives the development of &lt;i&gt;B&lt;/i&gt;?
&lt;/p&gt;
&lt;p&gt;
If I do, which one is driving the development of &lt;i&gt;B&lt;/i&gt;, &lt;i&gt;A&lt;/i&gt; or &lt;i&gt;BTest&lt;/i&gt;? (Of
course, ultimately it&apos;s &lt;i&gt;ATest&lt;/i&gt; that&apos;s driving, but if &lt;i&gt;A&lt;/i&gt; and &lt;i&gt;B&lt;/i&gt; are big
enough units, that&apos;s not enough.)
&lt;/p&gt;
&lt;p&gt;
If the former, I&apos;m not doing test driven development. If the latter, how
can I make sure the resulting &lt;i&gt;B&lt;/i&gt; satisfies the needs of its client &lt;i&gt;A&lt;/i&gt;? Or
should they both drive at the same time, which means a lot of
context-switching (both mental and concrete) and duplicating code between &lt;i&gt;A&lt;/i&gt;
and &lt;i&gt;BTest&lt;/i&gt;?
&lt;/p&gt;
&lt;p&gt;
The question isn&apos;t just theoretical, it&apos;s very practical. When applying
the principle of &lt;a href=&quot;http://www.jroller.com/page/wipu?entry=coding_by_need&quot;&gt;coding by need&lt;/a&gt; , it&apos;s the driving code from which
I create and navigate to the production code under modification.
&lt;/p&gt;
&lt;p&gt;
Where should I press ctrl-1 to create &lt;i&gt;B&lt;/i&gt; or one of its methods? Where
should I ctrl-click to navigate to it so I can make it work?
&lt;/p&gt;
&lt;p&gt;
Fortunately the two questions above give a hint to a solution: two
driver candidates and two questions...
&lt;/p&gt;

&lt;h5&gt;The solution&lt;/h5&gt;

&lt;p&gt;
The primary need that justifies the creation of &lt;i&gt;B&lt;/i&gt; is in &lt;i&gt;A&lt;/i&gt;. So I code by
intention and write the algorithm in &lt;i&gt;A&lt;/i&gt; that needs &lt;i&gt;B&lt;/i&gt;, using ctrl-1 to
create a stub &lt;i&gt;B&lt;/i&gt;, never really mentally leaving &lt;i&gt;A&lt;/i&gt;. Eclipse will create
TODO comments in the stub &lt;i&gt;B&lt;/i&gt; so that I won&apos;t forget to test and fix &lt;i&gt;B&lt;/i&gt; even if the
default &quot;return null&quot; happens to work for &lt;i&gt;A&lt;/i&gt;.
&lt;/p&gt;
&lt;p&gt;
So far &lt;i&gt;A&lt;/i&gt; has driven the creation of the &lt;i&gt;B&lt;/i&gt; &lt;u&gt;interface&lt;/u&gt; (in this context
interface is more or less a synonym for signature).
&lt;/p&gt;
&lt;p&gt;
Now when I have one client for the new service that &lt;i&gt;B&lt;/i&gt; provides, it&apos;s
time to think more about the service and try to find the general
contract its interface implies. This is where &lt;i&gt;BTest&lt;/i&gt; takes over and
starts to drive the &lt;u&gt;semantics&lt;/u&gt; or implementation of the newly created interface.
&lt;/p&gt;
&lt;p&gt;
Put another way, &lt;i&gt;A&lt;/i&gt; serves as a prototype that sketches one usage
scenario for &lt;i&gt;B&lt;/i&gt;. Most of the do-undo-redo work probably happens here.
This prototype gives enough insight of the nature of &lt;i&gt;B&lt;/i&gt; so it&apos;s
straightforward to make all assumptions as general and explicit as
possible by writing them as tests in &lt;i&gt;BTest&lt;/i&gt;.
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Server-client_is_a_deployment_model,_not_architectural.html</guid>
      <title>Server-client is a deployment model, not architectural</title>
      <link>http://blog.ville.oikarinen.org/Server-client_is_a_deployment_model,_not_architectural.html</link>
      <pubDate>Wed, 4 Jan 2006 05:18:46 -0500</pubDate>
      <category>Software Architecture</category>
      <description>&lt;p&gt;
Separating interface and implementation is a good old principle,
but surprisingly often it is violated.
&lt;/p&gt;

&lt;p&gt;
Maybe one reason for this is the misunderstood role of the server-client model.
&lt;/p&gt;

&lt;p&gt;
The server-client model is a &lt;i&gt;deployment&lt;/i&gt; model. Or in other words, it describes the runtime properties of an application.
&lt;/p&gt;

&lt;p&gt;
However, in software architecture (in the source-code maintainability sense) these two layers are not enough. The server
needs to be split into two: the api and its implementation.
&lt;/p&gt;

&lt;p&gt;
So the &quot;minimal&quot; set of modules for a client-server application is client-api-apiimpl.
&lt;/p&gt;

&lt;p&gt;
Of course, there can be several client and server implementations, but 3 is the minimum number of modules.
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Splitting_project_to_subprojects_for_easy_dependency_management.html</guid>
      <title>Splitting project to subprojects for easy dependency management</title>
      <link>http://blog.ville.oikarinen.org/Splitting_project_to_subprojects_for_easy_dependency_management.html</link>
      <pubDate>Wed, 14 Dec 2005 06:59:46 -0500</pubDate>
      <category>Eclipse</category>
      <description>&lt;p&gt;
I have found splitting a project to many subprojects an efficient way to make it difficult for coworkers to break the architecture by accidentally creating unwanted dependencies.
&lt;/p&gt;
&lt;p&gt;
If a programmer tries to create an illegal dependency, Eclipse won&apos;t even suggest importing the depended class, because it doesn&apos;t belong to the classpath.
&lt;/p&gt;
&lt;p&gt;
The untrivial part of this strategy are (unit) tests and their utilitity classes (for example mocks). They often need dependencies that are not wanted in the production code (see &lt;a href=&quot;http://jroller.com/page/wipu?entry=easy_testing_with_embedded_openejb&quot;&gt;my blog entry about hsql and openejb&lt;/a&gt; for example).
&lt;/p&gt;
&lt;p&gt;
The solution is to create subprojects &lt;code&gt;theproduct-tests&lt;/code&gt; and &lt;code&gt;theproduct-testutils&lt;/code&gt; and add all needed projects and libraries to their classpaths. Now the source directory for unit tests of any module &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;theproduct-x/tests&lt;/code&gt; but &lt;code&gt;theproduct-tests/unittests&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
I apply this same subproject principle to 3rd party utilities (both production and test). For example database, xml and xunit libraries all have subprojects of their own. This way I have fine-grained control over dependencies to them, too.
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Only_different_in_your_mind.html</guid>
      <title>Only different in your mind</title>
      <link>http://blog.ville.oikarinen.org/Only_different_in_your_mind.html</link>
      <pubDate>Thu, 24 Nov 2005 03:21:36 -0500</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
Software creates it, makes it grow. It&apos;s structure surrounds us and binds us. Semantic beings are we, not this crude tagged text. 
&lt;/p&gt;
&lt;p&gt;
You must feel the XML around you. Here, between you...me...the Mac...the Unix...everywhere! Yes, even between this land and that other operating system!
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Coding_by_need.html</guid>
      <title>Coding by need</title>
      <link>http://blog.ville.oikarinen.org/Coding_by_need.html</link>
      <pubDate>Fri, 7 Oct 2005 10:02:32 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
Test driven development essentially means that the only legitimate reason to write code
is a failing test.
&lt;/p&gt;

&lt;p&gt;
I think this same &quot;laziness&quot; principle applies on the coding level, too: Failing compilation should be the only legitimate reason to create/modify classes and methods.
&lt;/p&gt;

&lt;p&gt;
In practice this means that in general you should first write the call and only then the called class or method. I call this &lt;i&gt;quickfix coding&lt;/i&gt; (from the quickfix feature of Eclipse).
&lt;/p&gt;

&lt;p&gt;
This relates closely to the &lt;i&gt;coding by intention&lt;/i&gt; principle mentioned in some XP book (maybe &lt;i&gt;XP installed&lt;/i&gt;).
Coding by intention helps in keeping your thoughts in one thing at a time. Furthermore it produces more readable code.
&lt;/p&gt;

&lt;p&gt;
Quickfix coding is more economic, too: you need fewer keystrokes as the IDE creates the signature for you. And you&apos;ll rarely need to manually open files or keep several of them open: if you start from the caller, you can always ctrl-click the call to open the called file and close it after the modification.
&lt;/p&gt;

&lt;p&gt;
I think &lt;i&gt;Coding by need&lt;/i&gt; is a nice common name for TDD and Quickfix coding.
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/CVS_module_structure_for_a_multiproject_with_a_main_build_script.html</guid>
      <title>CVS module structure for a multiproject with a main build script</title>
      <link>http://blog.ville.oikarinen.org/CVS_module_structure_for_a_multiproject_with_a_main_build_script.html</link>
      <pubDate>Fri, 12 Aug 2005 02:30:35 -0400</pubDate>
      <category>SCM &amp; process</category>
      <description>This may sound stupid to CVS gurus, but for me it took years to invent this essentially simple trick.
&lt;p&gt;
A common multiproject workspace structure is like this:
&lt;ul&gt;
  &lt;li&gt;product-x-workspace&lt;/li&gt;
  &lt;ul&gt;
    &lt;li&gt;the_main_buildfile&lt;/li&gt;
    &lt;li&gt;the_main_readme&lt;/li&gt;
    &lt;li&gt;the_main_license&lt;/li&gt;
    &lt;li&gt;subproject-a&lt;/li&gt;
    &lt;ul&gt;
      &lt;li&gt;buildfile_a&lt;/li&gt;
      &lt;li&gt;src&lt;/li&gt;
    &lt;/ul&gt;
    &lt;li&gt;subproject-b&lt;/li&gt;
    &lt;ul&gt;
      &lt;li&gt;buildfile_b&lt;/li&gt;
      &lt;li&gt;src&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/ul&gt;
&lt;/ul&gt;

If I wanted to use a separate submodule for the main buildfile as well as for the individual subprojects, I didn&apos;t find a way to include them directly to the workspace root. Instead I got a subdirectory for them.
&lt;p&gt;
Here is the solution: Assume subproject-a has been imported to &lt;code&gt;cvsroot/projecta&lt;/code&gt;, subproject-b to &lt;code&gt;cvsroot/projectb&lt;/code&gt; and the main buildscript etc to &lt;code&gt;cvsroot/commonfiles&lt;/code&gt;. Now, the following module definition
&lt;pre&gt;
subproject-a -d product-x-workspace/subproject-a projecta
subproject-b -d product-x-workspace/subproject-b projectb
ws-commonfiles -d product-x-workspace commonfiles the_main_buildfile the_main_readme the_main_license
product-x-workspace -d . &amp;subproject-a &amp;subproject-b &amp;ws-commonfiles
&lt;/pre&gt;

will give the wanted workspace structure using command &lt;code&gt;cvs co product-x-workspace&lt;/code&gt;.</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Easy_testing_with_embedded_openejb_and_hsql.html</guid>
      <title>Easy testing with embedded openejb and hsql</title>
      <link>http://blog.ville.oikarinen.org/Easy_testing_with_embedded_openejb_and_hsql.html</link>
      <pubDate>Tue, 3 May 2005 09:34:33 -0400</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
In my current project I happened to question the need to install and set up a DBMS and an EJB container just to be able to run automatic tests during development. Luckily I found out that both openejb and hsql can be &quot;embedded&quot; i.e. used in-process with no per-workspace configuration.
&lt;/p&gt;
&lt;p&gt;
Now a new developer needs just pull the stuff from CVS and run the tests and they pass. No installation and no configuration, just Plain Old Coding TM :)
&lt;/p&gt;
&lt;p&gt;
Here is a quick HOWTO:
&lt;/p&gt;
&lt;p&gt;
1 Make a stripped down &quot;installation&quot; of openejb. The full installation works ok, too, but it&apos;s quite slow to start:
&lt;ul&gt;
&lt;li&gt;unzip the openejb package (I used 0.9.2) e.g. to tools/openejb under your project&lt;/li&gt;
&lt;li&gt;keep dist, lib, conf/logging.conf, conf/openejb.conf and delete everything else&lt;/li&gt;
&lt;li&gt;make a minimal conf/openejb.conf (this example only supports stateless session beans):&lt;/li&gt;
&lt;pre&gt;
&amp;lt;openejb&gt;

&amp;lt;Container id=&quot;Default Stateless Container&quot; ctype=&quot;STATELESS&quot;&gt;
    StrictPooling  true
&amp;lt;/Container&gt;

&amp;lt;Deployments dir=&quot;../../build/deploy&quot; /&gt;

&amp;lt;/openejb&gt;
&lt;/pre&gt;
&lt;li&gt;fix the log file paths in conf/logging.conf so logs are written under the temporary build directory OR configure log4j manually before calling any openejb code in your code&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;
2 Add all openejb jars (dist/* and lib/*) and hsql.jar to classpath
&lt;/p&gt;
&lt;p&gt;
3 Make your build script create the ejb jar under build/deploy
&lt;/p&gt;
&lt;p&gt;
Now you can use the embedded openejb by creating the initial context like this:
&lt;pre&gt;
        Properties properties = new Properties();
        properties.put(Context.INITIAL_CONTEXT_FACTORY,
                &quot;org.openejb.client.LocalInitialContextFactory&quot;);
        // here &quot;../your-ejb-project&quot; makes this test work in any project:
        System.setProperty(&quot;openejb.home&quot;,
                &quot;../your-ejb-project/tools/openejb&quot;);

        InitialContext ctx = new InitialContext(properties);
&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;
The embedded volatile hsql DBMS can be used by creating the connection like this:
&lt;pre&gt;
        Class.forName(&quot;org.hsqldb.jdbcDriver&quot;);
        Connection c = DriverManager.getConnection(&quot;jdbc:hsqldb:mem:aname&quot;,
                &quot;sa&quot;, &quot;&quot;);
&lt;/pre&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Multiple_exit_points_and_cyclomatic_complexity.html</guid>
      <title>Multiple exit points and cyclomatic complexity</title>
      <link>http://blog.ville.oikarinen.org/Multiple_exit_points_and_cyclomatic_complexity.html</link>
      <pubDate>Fri, 25 Feb 2005 07:56:00 -0500</pubDate>
      <category>Java</category>
      <description>&lt;p&gt;
I don&apos;t understand what is the rationale behind always using a single exit point in a function. I can only see the problem: it may increase cyclomatic complexity.
&lt;/p&gt;

&lt;p&gt;
Compare these two abstract examples and their cyclomatic complexity:
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Single exit point&lt;/b&gt;
&lt;pre&gt;
  int f(boolean a, boolean b) {
    // the compiler forces us to have a default value
    // even if we know it will never be used
    // (there is always a default value whether it is
    //  explicit or implicit)
    int value = DEFAULT;
    if( a ) {
      if( b ) {
        value = A_AND_B;
      } else {
        value = A_AND_NOT_B;
      }
    } else {
      value = NOT_A;
    }
    return value;
  }
&lt;/pre&gt;

&lt;b&gt;Multiple exit points&lt;/b&gt;
&lt;pre&gt;
  int f(boolean a, boolean b) {
    if( !a ) {
      return NOT_A;
    }

    // here we know a is true (otherwise we wouldn&apos;t be here)
    // so we don&apos;t need to increase the cyclomatic complexity by
    // introducing another level of indentation
    // (without a return statement we could never be so confident):
    if( b ) {
      return A_AND_B;
    }

    // here we know both a and b, no need for DEFAULT:
    return A_AND_NOT_B;
  }
&lt;/pre&gt;


&lt;/p&gt;
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/You_are_what_you_feed_your_brain_with.html</guid>
      <title>You are what you feed your brain with</title>
      <link>http://blog.ville.oikarinen.org/You_are_what_you_feed_your_brain_with.html</link>
      <pubDate>Fri, 25 Feb 2005 07:10:49 -0500</pubDate>
      <category>Art of programming</category>
      <description>	&lt;p&gt;I believe we people make lots of unconscious choices when we design or write programs, and the bigger the stress and hurry, the less conscious we are about our choices.&lt;/p&gt;

	&lt;p&gt;Where do the choices come from? I believe we mimic patterns and principles we see around us.&lt;/p&gt;

	&lt;p&gt;With every new thing (technology, language, tool etc) we learn, we not only learn the details of that very thing, but also the more universal principles and patterns behind it. And this unconscious learning is what builds our &amp;#8220;unconscious pool of patterns&amp;#8220; that helps us create software under stress by doing some of the supposedly trivial choices for us and letting our conscience concentrate on the more unique problems.&lt;/p&gt;

	&lt;p&gt;That&amp;#8216;s why I want to use &amp;#8220;the Mouse Oriented Operating System&amp;#8221; as little as possible, for example. (I&amp;#8216;m using it now, but that&amp;#8216;s my customer&amp;#8216;s choice, not mine :-). I don&amp;#8216;t want to pollute my brain with bad principles. I want to stand on the shoulders of a giant instead of a dwarf :-)&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Io_is_to_syntaxes_what_a_proverb_is_to_wise_thoughts.html</guid>
      <title>Io is to syntaxes what a proverb is to wise thoughts</title>
      <link>http://blog.ville.oikarinen.org/Io_is_to_syntaxes_what_a_proverb_is_to_wise_thoughts.html</link>
      <pubDate>Mon, 21 Feb 2005 09:31:42 -0500</pubDate>
      <category>Art of programming</category>
      <description>	&lt;p&gt;&lt;a href=&quot;http://www.iolanguage.com&quot; title=&quot;&quot;&gt;Io &lt;/a&gt;seems like a very promising language (or if the community won&amp;#8216;t grow for some reason, at least it will be a good concept to build upon).&lt;/p&gt;

	&lt;p&gt;There are lots of nice things about it (like prototypes), but what I liked most is its syntax: it is minimal (=machine-handleable) but readable. It reminds me of the Mathematica language, in which everything is a statement.&lt;/p&gt;

	&lt;p&gt;And it&amp;#8216;s really pure &lt;span class=&quot;caps&quot;&gt;OOP&lt;/span&gt;: even the code itself consists of objects. Could Io finally be &amp;#8220;the one&amp;#8221;: &lt;span class=&quot;caps&quot;&gt;LISP&lt;/span&gt; power with a human-readable syntax!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Methods_belong_to_objects_-_or_do_they.html</guid>
      <title>Methods belong to objects - or do they?</title>
      <link>http://blog.ville.oikarinen.org/Methods_belong_to_objects_-_or_do_they.html</link>
      <pubDate>Mon, 21 Feb 2005 09:11:43 -0500</pubDate>
      <category>Art of programming</category>
      <description>One of the differences between OOP and procedural programming is that OOP binds the data and its operations together.
&lt;p&gt;
So it could be said that an object &quot;owns&quot; its methods.
&lt;p&gt;
From the object user&apos;s point of view this all there is to it. You see an object with methods just waiting for you to call them, and you can really think of the object &quot;owning&quot; the methods.
&lt;p&gt;
However, from the object creator&apos;s point of view (or class creator&apos;s, if you are not using a prototype based flavor of OOP), it&apos;s not that simple: it would be nice to be able to define a method simultaneously for a bunch of objects (classes). And like we all know, inheritance allows just that. And since inheritance is a &quot;is-a-kind-of&quot; relation, again we can think that the method really &quot;belongs to&quot; the object - if not directly, at least via inheritance.
&lt;p&gt;
But it&apos;s not always possible (or appropriate) to use inheritance to &quot;reuse a method&quot;. 
You can always use delegation instead and maybe even use a code generator to help creating the forwarder methods, but that&apos;s not really a formal or solid way of reusing methods. For example, you need to run the generator again if the proxied class&apos;s signature changes.
&lt;p&gt;
But is it really a fundamental principle in OOP that the only mechanism for method reuse is inheritance? Is it really forbidden for a language to provide a syntax for defining methods &quot;outside the class definition&quot;?
&lt;p&gt;
I don&apos;t think so. Most languages just are that way but there could be dozens of different syntaxes for defining a method for different objects simultaneously
&lt;p&gt;
And some mechanisms already exist:
&lt;ul&gt;
  &lt;li&gt;Aspects let you modify the contents of methods&lt;/li&gt;
  &lt;li&gt;Ruby mixins let you define new methods&lt;/li&gt;
  &lt;li&gt;Doclets and other annotations can do many different things to an object&lt;/li&gt;
  &lt;li&gt;Haskell and other functional languages let you define methods outside the class definition&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;b&gt;Conclusion&lt;/b&gt;
&lt;p&gt;
From the object user&apos;s point of view methods do belong to their object, but from the creator&apos;s point of view they don&apos;t, and language syntaxes shouldn&apos;t pretend they do. In procedural languages there was no connection between the data and its operations. In OOP languages there is a connection, but the syntax for defining that connection should be as flexible as possible.
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Formalize_and_expand.html</guid>
      <title>Formalize and expand</title>
      <link>http://blog.ville.oikarinen.org/Formalize_and_expand.html</link>
      <pubDate>Thu, 3 Feb 2005 08:21:04 -0500</pubDate>
      <category>Art of programming</category>
      <description>&lt;p&gt;
A &lt;a href=&quot;http://www.theserverside.com/news/thread.tss?thread_id=31439&quot;&gt;
thread in theserverside
&lt;/a&gt;
about whether OOP is good or not stroke a nerve and nicely coincided with my current thoughts about automation.
&lt;/p&gt;

&lt;p&gt;
I haven&apos;t studied psychology, but I think thinking can be described as building abstractions and processing them with language (which is an abstraction, too). The goal is to use the abstractions as building blocks for new abstractions and repeating this ad infimum.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;The limits of language are the limits of one&apos;s world&lt;/i&gt;
&lt;br/&gt;&amp;nbsp;&lt;i&gt;- Ludwig Von Wittgenstein&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
In software development I think the only way to proceed is to formalize all good practices and other &quot;manual&quot; stuff.
&lt;/p&gt;

&lt;p&gt;
Take programming paradigms as an example of how they formalize things that were only &quot;best practices&quot; (or several of them competing) in their predecessor:
&lt;ul&gt;
&lt;li&gt;In assembly there are many ways to pass function parameters (stack, register, heap or some combination). In procedural languages this has been formalized as a new abstraction.&lt;/li&gt;
&lt;li&gt;In procedural languages you need to check the data to know what functions to use on it. In OOP the built-in polymorphism mechanism takes care of that.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;
Of course OOP has its problems. But the answer is not go back, but forward. It&apos;s much easier to build another abstraction level using OOP than &quot;skip over it&quot; using the procedural paradigm.
&lt;/p&gt;
&lt;p&gt;
(There are other &quot;branches&quot; of paradigms like functional or logic programming that most certainly have potential as building blocks for future languages.)
&lt;/p&gt;

&lt;p&gt;
This is what I meant in my &lt;a href=&quot;http://jroller.com/page/wipu/20050201#automation_best_form_of_documentation&quot;&gt;earlier blog&lt;/a&gt;: keeping the process manual prevents you from building upon the current process.
&lt;/p&gt;

&lt;p&gt;
But why is that people who are capable of using formal languages (i.e. programmers) are so reluctant to use their ability in SCM? I have several theories, but more about them later...
&lt;/p&gt;

</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/Automation_as_documentation__programming_machines,_not_humans.html</guid>
      <title>Automation as documentation: programming machines, not humans</title>
      <link>http://blog.ville.oikarinen.org/Automation_as_documentation__programming_machines,_not_humans.html</link>
      <pubDate>Wed, 2 Feb 2005 02:49:54 -0500</pubDate>
      <category>SCM &amp; process</category>
      <description>&amp;lt;sarcasm&gt;&lt;br/&gt;

It&apos;s amusing to read some HOWTO documentation for the &quot;mouse-oriented&quot; operating system and other software infected by its &quot;philosophy&quot;:
&lt;br/&gt;
&lt;i&gt;&quot;Select item A from menu B. Type value C to field D. Press button E.&quot;&lt;/i&gt;
&lt;br/&gt;&lt;br/&gt;
Whereas Unix users write scripts that utilize software tools, in the &quot;mouse-oriented&quot; world software vendors utilize the poor users.
&lt;br/&gt;&lt;br/&gt;
&lt;i&gt;Q: Where do you want to go today?
&lt;br/&gt;
A: GOTO 10&lt;/i&gt;

&lt;br/&gt;&amp;lt;/sarcasm&gt;&lt;br/&gt;
&lt;br/&gt;
Seriously, in SCM this decadenze is far too common: good old principles are forgotten and the process is little if at all automatized.
&lt;br/&gt;
Automation is not only making things easier, it&apos;s about making things possible.
More about that later...
</description>
    </item>
    <item>
      <guid isPermaLink="true">http://blog.ville.oikarinen.org/First_post.html</guid>
      <title>First post</title>
      <link>http://blog.ville.oikarinen.org/First_post.html</link>
      <pubDate>Thu, 27 Jan 2005 09:43:59 -0500</pubDate>
      <category>General</category>
      <description>Decided to join the community :-)
</description>
    </item>
  </channel>
</rss>
